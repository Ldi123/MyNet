### 常量定义

【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。**反例**: `Long a = 2l;` 写的是数字的 21，还是 Long 型的 2

【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如: 缓存相关的常量放在类: CacheConsts 下；系统配置相关的常量放在类: ConfigConsts 下。

### OOP 规约

【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。

【强制】所有的覆写方法，必须加@Override 注解。**说明** : `getObject()` 与 `get0bject()` 的问题。一个是字母的 O，一个是数字的 0，加 `@Override`可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。

【强制】`Object` 的 `equals` 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 `equals`。 **正例** : `"test".equals(object);`**反例** : `object.equals("test");`

【强制】所有的相同类型的包装类对象之间值的比较，全部使用 `equals` 方法比较。

【推荐】使用索引访问用 `String` 的 `split` 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 `IndexOutOfBoundsException` 的风险。

【推荐】 类内方法定义顺序依次是: 公有方法或保护方法 > 私有方法 > `getter/setter` 方法。**说明** : 公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值较低，所有 `Service` 和 `DAO` 的 `getter/setter` 方法放在类体最后。

【推荐】 循环体内，字符串的连接方式，使用 `StringBuilder` 的 `append` 方法进行扩展。**说明** : 反编译出的字节码文件显示每次循环都会 `new` 出一个 `StringBuilder` 对象，然后进行 `append` 操作，最后通过 `toString` 方法返回 `String` 对象，造成内存资源浪费。

### 集合处理

【强制】使用工具类 `Arrays.asList()`把数组转换成集合时，不能使用其修改集合相关的方 法，它的 `add/remove/clear` 方法会抛出 `UnsupportedOperationException` 异常。**说明** : `asList` 的返回对象是一个 `Arrays` 内部类，并没有实现集合的修改方法。`Arrays.asList` 体现的是适配器模式，只是转换接口，后台的数据仍是数组。

【强制】不要在 `foreach` 循环里进行元素的 `remove/add` `操作。remove` 元素请使用 `Iterator` 方式，如果并发操作，需要对 `Iterator` 对象加锁。

【推荐】集合初始化时，指定集合初始值大小。**说明** : `HashMap` 使用 `HashMap(int initialCapacity)` 初始化， **正例** : `initialCapacity = (需要存储的元素个数 / 负载因子) + 1`。注意负载因子(即 loaderfactor)默认为 0.75，如果暂时无法确定初始值大小，请设置为 16。**反例** : `HashMap` 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大，resize 需要重建 hash 表，严重影响性能。

【推荐】使用 `entrySet` 遍历 `Map` 类集合 KV，而不是 `keySet` 方式进行遍历。
**说明** : `keySet` 其实是遍历了 2 次，一次是转为 `Iterator` 对象，另一次是从 `hashMap` 中取出 `key` 所对应的 `value`。而 `entrySet` 只是遍历了一次就把 `key` 和 `value` 都放到了 `entry` 中，效率更高。如果是 JDK8，使用 `Map.foreach` 方法。**正例** : `values()` 返回的是 V 值集合，是一个 `list` 集合对象；`keySet()` 返回的是 K 值集合，是一个 `Set` 集合对象；`entrySet()` 返回的是 K-V 值组合集合 。

### 并发处理

【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。**说明** : 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资 源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。

【强制】`SimpleDateFormat` 是线程不安全的类，一般不要定义为 `static` 变量，如果定义为 `static`，必须加锁，或者使用 `DateUtils` 工具类。

【推荐】避免 `Random` 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。**说明** : `Random` 实例包括 `java.util.Random` 的实例或者 `Math.random()` 的方式。**正例** : 在 JDK7 之后，可以直接使用 API `ThreadLocalRandom`，而在 JDK7 之前，需要编码保证每个线程持有一个实例。

【推荐】除常用方法(如 getXxx/isXxx)等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。

【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作(这个 try-catch 是否可以移至循环体外)。

【参考】合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。如果无用，则删除。
	**说明** : 代码被注释掉有两种可能性: 1)后续会恢复此段代码逻辑。2)永久不用。前者如果没 有备注信息，难以知晓注释动机。后者建议直接删掉(代码仓库保存了历史代码)。

【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。 说明: 不要在方法体内定义: `Pattern pattern = Pattern.compile(规则);`

【强制】注意 `Math.random()` 这个方法返回是 double 类型，注意取值的范围 0≤x<1(能够取到零值，注意除零异常)，如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。

【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。

### 异常处理

【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。

【强制】对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。

【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。

【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。

【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。
	**说明** : 如果 JDK7 及以上，可以使用 try-with-resources 方式。

【强制】不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。

【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。
	**说明** : 如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。

【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景:
 1)返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。
	**反例** : `public int f() { return Integer 对象}`， 如果为 null，自动解箱抛 NPE。
 2) 数据库的查询结果可能为 null。
 3) 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。
 4) 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。
 5) 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。
 6) 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。
	**正例** : 使用 JDK8 的 Optional 类来防止 NPE 问题。

【参考】在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简短信息”。

【参考】避免出现重复的代码(Don’t Repeat Yourself)，即 DRY 原则。
**说明** : 随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是共用模块。

### 日志规范

【强制】打日志必须使用参数化信息的方式:

```javascript
logger.debug("Processing trade with id:[{}] and symbol : [{}] ", id, symbol);
```

不要进行字符串拼接,那样会产生很多String对象，占用空间，影响性能。

```javascript
logger.debug("Processing trade with id: " + id + " symbol: " + symbol);
```

使用[]进行参数变量隔离，如有参数变量，应该写成如下写法:

```javascript
logger.debug("员工[{}] [{}]年[{}]月应得薪资为[{}]",employee,year,month,actualSalary);
```

这样的格式写法，可读性更好，对于排查问题更有帮助。

【参考】如果进行了抛出异常操作，请不要记录error日志，由最终处理方进行处理：

反例(不要这么做):

```javascript
try{
    ....
}catch(Exception ex){
  String errorMessage=String.format("Error while reading information of user [%s]",userName);
  logger.error(errorMessage,ex);
  throw new UserServiceException(errorMessage,ex);
}
```

【参考】[关于打印debug日志是否加判断日志级别的分析 - 简书 (jianshu.com)](https://www.jianshu.com/p/d26024dbe9d1)

【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘 撑爆，并记得及时删除这些观察日志。通常，在生产环境中，应该将日志级别设置为 WARN 或 ERROR，而在开发环境中，可以将日志级别设置为 DEBUG 或 TRACE。

### MYSQL 数据库

#### [#](#建表规约) 建表规约

1. 【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint( 1 表示是，0 表示否)。
   **说明** : 任何字段如果为非负数，必须是 unsigned。
   **正例** : 表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。
2. 【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。
   **正例** : getter_admin，task_config，level3_name
   **反例** : GetterAdmin，taskConfig，level_3_name
3. 【强制】表名不使用复数名词。
   **说明** : 表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。
4. 【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。
5. 【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。
   **说明** : pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。
6. 【强制】小数类型为 decimal，禁止使用 float 和 double。
   **说明** : float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。
7. 【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。
8. 【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。
9. 【强制】表必备三字段: id, gmt_create, gmt_modified。 **说明** : 其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 date_time 类型。
10. 【推荐】表的命名最好是加上“业务名称_表的作用”。
    **正例** : tiger_task / tiger_reader / mpp_config
11. 【推荐】库名与应用名称尽量一致。
12. 【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。
13. 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循:
     1)不是频繁修改的字段。
     2)不是 varchar 超长字段，更不能是 text 字段。
    **正例** : 商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存 储类目名称，避免关联查询。
14. 【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。
    **说明** : 如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。
15. 【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。
    **正例** : 如下表，其中无符号值可以避免误存负数，且扩大了表示范围。

| 对象     | 年龄区间   | 类型              | 表示范围                       |
| :------- | :--------- | :---------------- | :----------------------------- |
| 人       | 150 岁之内 | unsigned tinyint  | 无符号值: 0 到 255             |
| 龟       | 数百岁     | unsigned smallint | 无符号值: 0 到 65535           |
| 恐龙化石 | 数千万年   | unsigned int      | 无符号值: 0 到约 42.9 亿       |
| 太阳     | 约 50 亿年 | unsigned bigint   | 无符号值: 0 到约 10 的 19 次方 |

#### [#](#索引规约) 索引规约

1. 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 说明: 不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。
2. 【强制】 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。
   **说明** : 即使双表 join 也要注意表索引、SQL 性能。
3. 【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。
   **说明** : 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。
4. 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。
   **说明** : 索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。
5. 【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。
   **正例** : where a=? and b=? order by c; 索引: a_b_c
   **反例** : 索引中有范围查找，那么索引有序性无法利用，如: WHERE a>10 ORDER BY b; 索引 a_b 无法排序。
6. 【推荐】利用覆盖索引来进行查询操作，避免回表。
   **说明** : 如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗? 目录浏览一下就好，这个目录就是起到覆盖索引的作用。
   **正例** : 能够建立索引的种类: 主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种 效果，用 explain 的结果，extra 列会出现: using index。
7. 【推荐】利用延迟关联或者子查询优化超多分页场景。
   **说明** : MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。
   **正例** : 先快速定位需要获取的 id 段，然后再关联: SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id
8. 【推荐】SQL 性能优化的目标: 至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。
   **说明** :
    1) consts 单表中最多只有一个匹配行(主键或者唯一索引)，在优化阶段即可读取到数据。
    2) ref 指的是使用普通的索引(normal index)。
    3) range 对索引进行范围检索。
   **反例** : explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。
9. 【推荐】建组合索引的时候，区分度最高的在最左边。
   **正例** : 如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。
   **说明** : 存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如: where a>? and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。
10. 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。
11. 【参考】创建索引时避免有如下极端误解:
     1)宁滥勿缺。误认为一个查询就需要建一个索引。
     2)宁缺勿滥。误认为索引会消耗空间、严重拖慢更新和新增速度。
     3)抵制惟一索引。误认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。

#### [#](#sql-语句) SQL 语句

1. 【强制】不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。
   **说明** : count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。

2. 【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。

3. 【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。
   **正例** : 可以使用如下方式来避免 sum 的 NPE 问题: SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;

4. 【强制】使用 ISNULL()来判断是否为 NULL 值。注意: NULL 与任何值的直接比较都为 NULL。
   **说明** :

   ```java
       1) NULL<>NULL 的返回结果是 NULL，而不是 false。  
       2) NULL=NULL 的返回结果是 NULL，而不是 true。  
       3) NULL<>1 的返回结果是 NULL，而不是 true。  
   ```

5. 【强制】在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。

6. 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。
   **说明** : (概念解释)学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速

7. 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。

8. 【强制】数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。

9. 【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。

10. 【参考】如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。
    **说明** :
     SELECT LENGTH("轻松工作")； 返回为 12
     SELECT CHARACTER_LENGTH("轻松工作")； 返回为 4
     如果要使用表情，那么使用 utfmb4 来进行存储，注意它与 utf-8 编码的区别。

11. 【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。
    **说明** : TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。

#### [#](#orm-映射) ORM 映射

1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。
   **说明** : 1)增加查询分析器解析成本。2)增减字段容易与 resultMap 配置不一致。

2. 【强制】POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。
   **说明** : 参见定义 POJO 类以及数据库字段定义规定，在`<resultMap>`中增加映射，是必须的。在 MyBatis Generator 生成的代码中，需要进行对应的修改。

3. 【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。
   **说明** : 配置映射关系，使字段与 DO 类解耦，方便维护。

4. 【强制】sql.xml 配置参数使用: #{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。

5. 【强制】iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。
   **说明** : 其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList 取 start,size 的子集合。
   **正例** :

   ```
    Map<String, Object> map = new HashMap<String, Object>();
    map.put("start", start);
    map.put("size", size);
   ```

6. 【强制】不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。
   **说明** : resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。

7. 【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。

8. 【推荐】不要写一个大而全的数据更新接口，传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。

9. 【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。

10. 【参考】`<isEqual>`中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；`<isNotEmpty>`表示不为空且不为 null 时执行；`<isNotNull>`表示不为 null 值时执行。

### 服务器

1. 【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。 说明: 操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服 务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上 调小此等待值。
   **正例** : 在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值(秒): net.ipv4.tcp_fin_timeout = 30
2. 【推荐】调大服务器所支持的最大文件句柄数(File Descriptor，简写为 fd)。
   **说明** : 主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理，即一个连接对 应于一个 fd。主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。 建议将 linux 服务器所支持的最大句柄数调高数倍(与服务器的内存数量相关)。
3. 【推荐】给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。
   **说明** : OOM 的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错 非常有价值。
4. 【参考】服务器内部重定向使用 forward；外部重定向地址使用 URL 拼装工具类来生成，否则 会带来 URL 维护不一致的问题和潜在的安全风险。