(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{535:function(v,_,t){"use strict";t.r(_);var r=t(9),a=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h4",{attrs:{id:"关于传值调用和引用调用的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关于传值调用和引用调用的理解"}},[v._v("#")]),v._v(" 关于传值调用和引用调用的理解")]),v._v(" "),_("p",[v._v("传值调用\n实参----\x3e形参（实参传数给形参，形参获得实参的数值），改变形参不改变原先的实参，因为两者在获得值之后没有任何关系。")]),v._v(" "),_("p",[v._v("引用调用\n实参----\x3e形参（实参传地址给形参，形参获得实参的地址），改变形参会反映在存储单元中，实参会被改变。")]),v._v(" "),_("p",[v._v("只有实参传值或者地址给形参！\n没有形参穿值或者地址给实参的说法！")]),v._v(" "),_("p",[v._v("形参没有确定的值，只能是变量。\n实参可以是常量、变量、表达式、函数。\n实参可以是表达式, 但不是“任意”，表达式计算结果的 类型 必须与 形参一致。当然数值不能超界溢出。")]),v._v(" "),_("p",[v._v("例：")]),v._v(" "),_("p",[v._v("已知函数f1()、f2()的定义如下，调用f1时为传值调用，调用f2时为引用调用。设有函数调用t＝f1(5)，那么调用执行后t的值为（ 1 ）。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Ldi123/my-image@master/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%9B%BE/yinyongdiaoyong.png",alt:"yinyongdiaoyong"}})]),v._v(" "),_("p",[v._v("解析：首先a=f2（x）=f2（1），代入到f2中进行运算，经过运算（x=x-1)后，x的值为0，f2返回值为1。这里x是引用调用，所以x的终值为0，然后f2的返回值1赋给了a。所以a=1。最终t的值为a+x=1。")]),v._v(" "),_("h4",{attrs:{id:"类结构型模式和对象结构型模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类结构型模式和对象结构型模式"}},[v._v("#")]),v._v(" 类结构型模式和对象结构型模式")]),v._v(" "),_("p",[v._v("结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。")]),v._v(" "),_("p",[v._v("由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。")]),v._v(" "),_("p",[v._v("结构型模式分为以下 7 种：")]),v._v(" "),_("ol",[_("li",[v._v("代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。")]),v._v(" "),_("li",[v._v("适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。")]),v._v(" "),_("li",[v._v("桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。")]),v._v(" "),_("li",[v._v("装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。")]),v._v(" "),_("li",[v._v("外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。")]),v._v(" "),_("li",[v._v("享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。")]),v._v(" "),_("li",[v._v("组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。")])]),v._v(" "),_("p",[v._v("以上 7 种结构型模式，除了适配器模式分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式")]),v._v(" "),_("h4",{attrs:{id:"模块的7种内聚类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模块的7种内聚类型"}},[v._v("#")]),v._v(" 模块的7种内聚类型")]),v._v(" "),_("p",[v._v("模块间的耦合和模块的内聚是度量模块独立性的两个准则。内聚是模块功能强度的度量，即模块内部各个元素彼此结合的紧密程度。一个模块内部各元素之间的紧密程度越高，则其内聚性越高，模块独立性越好。模块内聚类型主要有以下几类:")]),v._v(" "),_("ol",[_("li",[v._v("偶然内聚或巧合内聚：指一个模块内的各处理元素之间没有任何联系。")]),v._v(" "),_("li",[v._v("逻辑内聚：指模块内执行若干个逻辑上相似的功能，通过参数确定该模块完成哪一个功能。")]),v._v(" "),_("li",[v._v("时间内聚：把需要同时执行的动作组合在一起形成的模块。")]),v._v(" "),_("li",[v._v("过程内聚：指一个模块完成多个任务，这些任务必须按指定的过程执行。")]),v._v(" "),_("li",[v._v("通信内聚：指模块内的所有处理元素都在同一数据结构上操作，或者各处理使用相同的输入数据或产生相同的输出数据。")]),v._v(" "),_("li",[v._v("顺序内聚：指一个模块中的各个处理元素都密切相关于同一各功能且必须顺序执行，前一个功能元素的输出就是下一个功能的输入。")]),v._v(" "),_("li",[v._v("功能内聚：指模块内的所有元素共同作用完成一个功能，缺一不可。")])]),v._v(" "),_("h4",{attrs:{id:"数据库实体属性基础知识"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库实体属性基础知识"}},[v._v("#")]),v._v(" 数据库实体属性基础知识")]),v._v(" "),_("ul",[_("li",[v._v("1、"),_("strong",[v._v("简单属性")]),v._v("：简单属性是原子的、不可再分的，例如某人的性别，如果不特别声明，通常都是指简单属性。")]),v._v(" "),_("li",[v._v("2、"),_("strong",[v._v("复合属性")]),v._v("：复合属性是相对于简单属性来说的，复合属性可以细分为更小的部分，即可以划分为别的属性，例如通信地址可以进一步划分为邮编、省、市和街道等。")]),v._v(" "),_("li",[v._v("3、"),_("strong",[v._v("单值属性")]),v._v("：指属性对于一个特定的实体都只有单独的一个值，例如对于一个特定的学生，在系统中只对应一个学号和身份证号。")]),v._v(" "),_("li",[v._v("4、"),_("strong",[v._v("多值属性")]),v._v("：多值属性是相对于单值属性来说的，在某些特定情况下，一个属性可以对应一组值，例如一个部门可以有多部电话，那么电话的属性就属于多值属性。")]),v._v(" "),_("li",[v._v("5、"),_("strong",[v._v("NULL属性")]),v._v("：当实体在某个属性上没有值，或属性值未知时，使用NULL值，表示无意义或不知道。")]),v._v(" "),_("li",[v._v("6、"),_("strong",[v._v("派生属性")]),v._v("：该属性可以从其他属性得出，例如“学生”实体中有“生日”和“年龄”等属性，从“生日”可以计算出“年龄”属性的值，“年龄”属性就是派生属性。")])]),v._v(" "),_("h4",{attrs:{id:"多态的四种不同形式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多态的四种不同形式"}},[v._v("#")]),v._v(" 多态的四种不同形式")]),v._v(" "),_("p",[v._v("在收到消息时，对象要予以响应。不同的对象收到同一消息可以产生完全不同的结果，这一现象称为多态。在使用多态的时候，用户可以发送一个通用的消息，而实现的细节由接收对象自行决定。这样，同一消息就可以调用不同的方法。多态的实现受到继承的支持，利用类继承的层次关系，把具有通用功能的消息存放在高层次，而不同的实现这一功能的行为放在较低层次，在这些低层次的对象能够给通用消息以不同的响应。")]),v._v(" "),_("p",[_("strong",[v._v("多态总体上分为：编译时的多态（静态多态）和运行时的多态（动态多态），Cardelli和Wegner把多态细分为4类：")])]),v._v(" "),_("ul",[_("li",[v._v("参数多态：采用参数化模板，通过给出不同的类型参数，使得一个结构有多种类型。如C++语言中的函数模板和类模板属于参数多态。参数多态又叫静态多态，它的执行速度快，异常少，调用在编译时已经确定。参数多态是应用比较广泛的一种多态，被称为最纯的多态。")]),v._v(" "),_("li",[v._v("包含多态：在许多语言中都存在，最常见的例子就是子类型化，即一个类型是另外一个类型的子类型。一般需要进行运行时的类型检查，属于动态多态。包含多态的基础是虚函数。虚函数是引入了派生概念后用来表现基类和派生类的成员函数之间的一种关系。")]),v._v(" "),_("li",[v._v("过载多态：同一个名字在不同的上下文中所代表的含义不同。典型的例子是运算符重载和函数重载，属于静态多态。")]),v._v(" "),_("li",[v._v("强制多态：编译程序通过语义操作，把操作对象的类型强行加以变换，以符合函数或操作符的要求。程序设计语言中基本类型的大多数操作符，在发生不同类型的数据进行混合运算时，编译程序一般都会进行强制多态。程序员也可以显示地进行强制多态的操作。如int+double,编译系统一般会把int转换为double,然后执行double+double运算，这个int->double的转换，就实现了强制多态，即可是隐式的，也可显式转换。强制多态属于静态多态。")])]),v._v(" "),_("h4",{attrs:{id:"用户界面设计原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#用户界面设计原则"}},[v._v("#")]),v._v(" 用户界面设计原则")]),v._v(" "),_("p",[v._v("✨简易性（便于使用和理解，减少错误选择的可能）")]),v._v(" "),_("p",[v._v("✨用户的语言（友好人性化提示，使用用户容易接受的方式）")]),v._v(" "),_("p",[v._v("✨记忆负担最小化（转换界面而不是选择一系列的命令行）")]),v._v(" "),_("p",[v._v("✨一致性（术语一致、风格和内容一致、色调字体一致等）")]),v._v(" "),_("p",[v._v("✨利用用户的熟悉程度（与其他众多的字体风格、按钮颜色等一致）")]),v._v(" "),_("p",[v._v("✨从用户的观点考虑（以用户为中心，用户参与界面设计）")]),v._v(" "),_("p",[v._v("✨排列分组（有序整齐方便查找和使用）")]),v._v(" "),_("p",[v._v("✨安全性（选择可逆，避免选错无法恢复）")]),v._v(" "),_("p",[v._v("✨人性化（从熟练用户和新手用户双方考虑，尽量可以根据需求定制界面）")]),v._v(" "),_("h4",{attrs:{id:"软件测试-白盒测试方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#软件测试-白盒测试方法"}},[v._v("#")]),v._v(" 软件测试--白盒测试方法")]),v._v(" "),_("p",[_("strong",[v._v("✔语句覆盖")]),v._v("\n顾名思义就是针对代码语句，设计出来的用例要保证程序中的每一个语句至少被执行一次。\n通常语句覆盖认为是“最弱覆盖”，因为它仅仅考虑对代码中的执行语句进行覆盖而没有考虑各种条件和分支，比较难以发现代码中的问题。\n"),_("strong",[v._v("✔分支覆盖")]),v._v("\n也称为判定覆盖，判定表达式至少获得一次“真”、“假”值。判定覆盖比语句覆盖强。\n"),_("strong",[v._v("✔条件覆盖")]),v._v("\n条件覆盖要求设计用例时针对判断语句里面每个条件表达式true 和 false各取值一次，不考虑判断语句的计算结果（不考虑组合情况）\n"),_("strong",[v._v("✔判定条件覆盖（分支条件覆盖）")]),v._v("\n设计测试用例时，使得判断语句中每个条件表达式的所有可能结果至少出现一次，每个判断语句本身所有可能结果也至少出现一次。\n"),_("strong",[v._v("✔组合覆盖")]),v._v("\n设计测试用例时，使得每个判断语句中条件结果的所有可能组合至少出现一次。\n"),_("strong",[v._v("✔路径覆盖")]),v._v("\n设计测试用例时，覆盖程序中所有可能的执行路径")]),v._v(" "),_("h4",{attrs:{id:"数据库-三层模式两层映像"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库-三层模式两层映像"}},[v._v("#")]),v._v(" 数据库 三层模式两层映像")]),v._v(" "),_("p",[_("strong",[v._v("🐉三层模式")])]),v._v(" "),_("ol",[_("li",[v._v("外模式： 又用户模式，应用程序接触外模式，外模式是数据库用户（应用程序员、最终用户）能够看到的使用的局部数据的逻辑结构和特征的描述，是数据库的数据视图，是与某一个应用有关的数据的逻辑表示。用户可以通过外模式描述语言来描述、定义对应于用户的数据记录(外模式)，也可以利用数据操纵语言(Data Manipulation Language，DML)对这些数据记录进行处理。")]),v._v(" "),_("li",[v._v("模式 ：也称为逻辑模式，它是DB中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。模式层是数据库模式结构的中间层，既不涉及到数据的物理存储细节和硬件环境，也与具体的应用程序、应用开发工具以及高级程序设计语言无关（C、C++、JAVA等）。")]),v._v(" "),_("li",[v._v("内模式： 又称存储模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。例如，记录的存储方式是顺序结构存储还是B树结构存储；索引按什么方式组织；数据是否压缩，是否加密；数据的存储记录结构有何规定等。")])]),v._v(" "),_("p",[_("strong",[v._v("🐉两层映像")])]),v._v(" "),_("ol",[_("li",[v._v("外模式/模式映象：定义在外模式描述中，把描述局部逻辑结构的外模式与描述全局逻辑结构的模式联系起来 ，保证逻辑独立性：当模式改变时，只要对外模式/模式映象做相应的改变，使外模式保持不变，则以外模式为依据的应用程序不受影响，从而保证了数据与程序之间的逻辑独立性，也就是数据的逻辑独立性。")]),v._v(" "),_("li",[v._v("模式/内模式映象：定义在模式描述中，把描述全局逻辑结构的模式与描述物理结构的内模式联系起来 ，保证物理独立性：当内模式改变时，比如存储设备或存储方式有所改变，只要模式/内模式映象做相应的改变，使模式保持不变，则应用程序保持不变。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Ldi123/my-image@master/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%9B%BE/20210623012906234.png",alt:"20210623012906234"}})]),v._v(" "),_("h4",{attrs:{id:"计算机网络-几个常见的网络协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算机网络-几个常见的网络协议"}},[v._v("#")]),v._v(" 计算机网络--几个常见的网络协议")]),v._v(" "),_("p",[v._v("🐣"),_("strong",[v._v("ARP协议")])]),v._v(" "),_("p",[v._v("在以太网中，源主机和目标主机进行通信，那么必须要知道目标主机的IP地址与MAC地址。通常目标主机的IP地址容易获得，如 ping 192.168.1.2，那么目标主机的MAC地址怎么获得呢？它是通过ARP地址解析协议获得的。ARP地址解析协议（address resolution protocol）基本功能是通过目标主机的IP地址查询目标主机的MAC地址，使源主机获得目标IP与MAC地址的对应关系，然后完成正常通信。ARP地址解析协议的工作原理如下。")]),v._v(" "),_("p",[v._v("🐣"),_("strong",[v._v("ICMP协议")])]),v._v(" "),_("p",[v._v("ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。")]),v._v(" "),_("p",[v._v("🐣"),_("strong",[v._v("DHCP协议")])]),v._v(" "),_("p",[v._v("DHCP（Dynamic Host Configuration Protocol）动态主机配置协议是一个"),_("a",{attrs:{href:"http://baike.baidu.com/view/788.htm",target:"_blank",rel:"noopener noreferrer"}},[v._v("局域网"),_("OutboundLink")],1),v._v("的"),_("a",{attrs:{href:"http://baike.baidu.com/view/16603.htm",target:"_blank",rel:"noopener noreferrer"}},[v._v("网络协议"),_("OutboundLink")],1),v._v("，使用"),_("a",{attrs:{href:"http://baike.baidu.com/view/30509.htm",target:"_blank",rel:"noopener noreferrer"}},[v._v("UDP"),_("OutboundLink")],1),v._v("协议工作， 主要有两个用途：给内部网络或"),_("a",{attrs:{href:"http://baike.baidu.com/view/1279152.htm",target:"_blank",rel:"noopener noreferrer"}},[v._v("网络服务"),_("OutboundLink")],1),v._v("供应商自动分配"),_("a",{attrs:{href:"http://baike.baidu.com/view/3930.htm",target:"_blank",rel:"noopener noreferrer"}},[v._v("IP地址"),_("OutboundLink")],1),v._v("，给用户或者内部"),_("a",{attrs:{href:"http://baike.baidu.com/view/31921.htm",target:"_blank",rel:"noopener noreferrer"}},[v._v("网络管理员"),_("OutboundLink")],1),v._v("作为对所有"),_("a",{attrs:{href:"http://baike.baidu.com/view/3314.htm",target:"_blank",rel:"noopener noreferrer"}},[v._v("计算机"),_("OutboundLink")],1),v._v("作中央管理的手段。DHCP有3个端口，其中UDP67和UDP68为正常的DHCP服务端口，分别作为DHCP Server和DHCP Client的服务端口；546号端口用于DHCPv6 Client，而不用于DHCPv4。")]),v._v(" "),_("h4",{attrs:{id:"区别主动攻击与被动攻击-以及如何防范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#区别主动攻击与被动攻击-以及如何防范"}},[v._v("#")]),v._v(" 区别主动攻击与被动攻击，以及如何防范")]),v._v(" "),_("p",[_("strong",[v._v("(1) 被动攻击")]),v._v("\n🍦：被动攻击是指在未经用户同意和认可的情况下攻击者嗅探窃听获得信息或数据文件并对其分析，但不对数据信息做任何修改，不影响系统的运行。被动攻击的本质是窃听或监视数据传输。")]),v._v(" "),_("p",[v._v("🍦：由于被动攻击不会对被动攻击对象做任何修改，留下的痕迹较少或根本没有留下任何痕迹，因而非常难以检测，所以抗击被动攻击的重点在于预防，具体的措施包括VPN(虚拟专用网络)、采用加密技术保护网络及使用加密保护的分布式网络等。")]),v._v(" "),_("p",[_("strong",[v._v("(2) 主动攻击")]),v._v("\n🍟：主动攻击是指攻击者通过有选择的修改、删除、延迟、乱序、复制、插入数据流或数据流的一部分以达到其非法目的，主动攻击主要涉及某些数据流的篡改或虚假数据流的产生，可能改变信息或危害系统，威胁信息完整性，可用性、真实性和有效性。主动攻击主要分为重放，篡改，伪造，拒绝服务")]),v._v(" "),_("p",[v._v("🍟：应对主动攻击的主要途径是检测，以及能从此攻击造成的破坏中及时地恢复，同时入侵检测系统或工具还具有某种遏制效果，在一定程度上也能起到防止攻击扩大的作用，具体的措施包括入侵检测、安全审计和完整性恢复等。")]),v._v(" "),_("h4",{attrs:{id:"补码编码的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#补码编码的理解"}},[v._v("#")]),v._v(" 补码编码的理解")]),v._v(" "),_("p",[v._v("例如二进制数：1111 和 0101")]),v._v(" "),_("p",[v._v("表示补码时：最高位表示符号位，值为1表示负数，值为0表示非负数")]),v._v(" "),_("p",[v._v("转换成十进制：用二进制每一位数乘以对于的权重，然后相加得到十进制表示的数值")]),v._v(" "),_("p",[v._v("于是：")]),v._v(" "),_("p",[v._v("[0101]~10~：-0·2^3^ + 1·2^2^ + 0·2^1^ + 1·2^0^  = 5")]),v._v(" "),_("p",[v._v("[1111]~10~：-1·2^3^ + 1·2^2^ + 1·2^1^ + 1·2^0^  = -1")]),v._v(" "),_("p",[v._v("补码所能表示的值的范围：")]),v._v(" "),_("ul",[_("li",[v._v("最小值[100···00]，也就是设置负权的位为1，其他位为0")]),v._v(" "),_("li",[v._v("最大值[011···11]，也就是清除具有负权值的位，设置其他位为1")])])])}),[],!1,null,null,null);_.default=a.exports}}]);